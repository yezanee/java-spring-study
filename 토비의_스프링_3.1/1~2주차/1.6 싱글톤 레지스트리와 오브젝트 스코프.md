# Intro

- 스프링의 애플리케이션과 오브젝트 팩토리는 같을까?
    - DaoFactory의 userDao() 메소드를 두 번 호출해서 리턴되는 UserDao 오브젝트 두 개는 같을까?
        
        ⚠️ 오브젝트의 동일성과 동등성
        
        `동일성` : 두 개의 오브젝트가 완전히 동일 (== 연산자 사용)
        
        `동등성` : 두 개의 오브젝트가 동일하진 않지만, 동일한 정보를 갖는 것 (equals() 사용)
        
        동일한 오브젝트는 동등하지만, 그 반대는 항상 참인 것은 아님
        
        코드를 보면 userDao 메소드를 호출할 때 마다 new 연산자로 새로운 오브젝트를 만듦
        
        → 오브젝트를 직접 출력하여 고유값이 완전히 동일하면 두 개는 `동일한` 오브젝트임
        
    - 출력해보니 리턴되는 오브젝트는 다른 오브젝트임
        
        `userDao를 매번 호출하면 계속 새로운 오브젝트가 만들어질 것` 
        
    - 그럼 이번엔 스프링의 애플리케이션을 사용해보자
        
        DaoFactory를 설정 정보로 등록하고 getBean() 메소드를 이용해 오브젝트를 가져옴
        
        여기서도 애플리케이션 컨텍스트가 userDao()메소드를 호출해서 만드는 건 마찬가지
        
    - 출력해보니 리턴되는 오브젝트는 `동일한` 오브젝트임
<br/>

- 오브젝트 팩토리와 스프링의 애플리케이션 컨텍스트 동작방식은 `다르다는 것!`
    - 팩토리는 매번 다른 오브젝트를 생성함
    - 애플리케이션 컨텍스트는 여러 번에 걸쳐 빈을 요청해도 동일한 오브젝트를 리턴
<br/>

# 1.6.1 싱글톤 레지스트리로서의 어플리케이션 컨텍스트

- 어플리케이션 컨텍스트
    - 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너
    - 동시에 싱글톤을 저장하고 관리하는 `싱글톤 레지스토리` 이기도 함
    - 스프링은 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 `전부` 싱글톤으로 만듦
<br/>

- 서버 애플리케이션과 싱글톤
    - 스프링은 왜 빈을 싱글톤으로 만드는 것일까?
    - 스프링이 주로 적용되는 대상이 `자바 엔터프라이즈 기술`을 사용하는 `서버환경`이기 때문
        
        독립형 프로그램을 개발할 수도 있으나, 태생적으로 엔터프라이즈를 위해 고안된 기술
        
        → 서버환경에서 그 가치가 있다
        
    - 스프링이 처음 설계 됐던 서버 환경은 `높은 성능`이 요구되는 환경이었음
        
        하나의 요청을 처리하기 위해 데이터 액세스, 서비스, 비즈니스, 프레젠테이션 등 다양한 기능을 담당하는 `오브젝트들이 참여하는 계층형 구조`로 이뤄짐
        
    - 그런데 매번 이런 로직 오브젝트를 만든다고 생각해보자
        
        요청 한 번에 5개의 오브젝트가 만들어지고 초당 500개의 요청이라면 초당 2500개의 오브젝트가 생성
        
        한 시간이면 900만개의 오브젝트임 → 부하가 걸려 서버가 감당하기 힘들어짐
        
    - 엔터프라이즈 분야에서는 `서비스 오브젝트` 개념을 사용해왔음
        
        `서블릿` : 자바 엔터프라이즈 기술의 가장 기본적인 서비스 오브젝트
        
        서블릿은 `멀티 스레드 환경`에서 싱글톤으로 동작
        
        서블릿 클래스 당 하나의 오브젝트만 만들고, 요청을 담당하는 멀티 스레드에서 하나의 오브젝트를 공유해 동시에 사용
        
    - `싱글톤 패턴의 원리`: 애플리케이션 안에 대게 한 개의 오브젝트만 만들어서 사용
    - 하지만 싱글톤 패턴은 사용하기 까다롭고 여러가지 문제점들이 존재함
    - 싱글톤 패턴: 디자인 패턴 중 하나, 어플리케이션 내에서 오브젝트가 하나만 존재하도록 강제함
<br/>
    
- 싱글톤 패턴의 한계
    - 싱글톤 구현법
        
        클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 `private`으로 만든다
        
        생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 `스태틱 필드`를 정의
        
        스태틱 팩토리 메소드인 getInstance()를 만들고, 이 메소드가 최초로 호출되는 시점에 `한 번만` 오브젝트를 만든다. 생성된 오브젝트는 스태틱 필드에 저장된다. (스태틱 필드의 초기값으로 오브젝트를 미리 만들어 둘 수도 있음)
        
        한 번 오브젝트(싱글톤)이 만들어지고 난 후에는 getInstance() 메소드를 통해 `이미 만들어둔 오브젝트를 넘겨줌`
        
    - 싱글톤 패턴을 적용한 UserDao
        
        ```jsx
        public class UserDao {
        	private static UserDao INSTANCE;
        	...
        	private UserDao(ConnectionMaker connectionMaker) { //생성자를 private으로
        		this.connectionMaker = connectionMaker;
        	}
        	public static synchronized UserDao getInstance() {
        		if(INSTANCE == null) INSTANCE = new UserDao(???);
        		//최초일 경우에만 오브젝트 생성
        		return INSTANCE; //만들어준 오브젝트를 넘겨줌
        	}
        }
        ```
        
        하지만, 싱글톤 패턴을 적용하니 코드가 지저분해짐
        
        private으로 정의된 생성자 때문에 DaoFactory에서 ConnectionMaker 오브젝트 넘김이 불가능해짐
        
        싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있음
        
    <br/>
    1️⃣ private 생성자를 갖고 있기 때문에 상속할 수 없다
    
    싱글톤 패턴은 생성자를 private으로 제한함 → 클래스 자신만이 오브젝트를 만들도록
    
    문제는 다른 생성자가 없다면 상속이 불가능해짐
    
    상속이 불가능 하다는 것은 객체지향의 장점인 `다형성을 적용할 수 없다`는 것
  
    <br/>
    
    2️⃣ 싱글톤은 테스트하기가 힘들다
    
    싱글톤은 테스트하기 힘들거나 아예 테스트가 불가능하다
    
    싱글톤은 초기화 과정에서 생성자를 통해 오브젝트를 주입하는 것이 힘들기 때문에 필요한 오브젝트는 직접 만들어서 사용하여야 함
    
    → 테스트용 오브젝트로 대체하기가 힘들다
    
    → 테스트는 엔터프라이즈 개발의 핵심이기 때문에 싱글톤 패턴을 사용하는 것은 큰 단점임
  
    <br/>
    
    3️⃣ 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
    
    서버에서 `클래스 로더를 어떻게 구성`하냐에 따라 싱글톤임에도 하나 이상의 오브젝트가 만들어질 수 있음
    
    → 서버환경에서는 싱글톤이 꼭 보장된다고 볼 수 없음
    
    여러게의 JVM에 분산되어 설치가 되어도, 독립적으로 오브젝트가 생겨 싱글톤의 가치가 하락
  
    <br/>
    
    4️⃣ 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
    
    싱글톤은 사용하는 클라이언트가 정해져 있지 않다 (여기저기서 다 사용가능하다는 뜻)
    
    `스태틱 메소드`를 이용해 쉽게 접근 가능하기 때문에 `전역 상태`로 사용되기 쉬움
    
    아무 객체나 접근하고, 수정하고, 공유하는 상태는 객체지향에서 권장되지 않음
    
    → 아예 스태틱 필드와 메소드로만 구성된 클래스를 사용하는 것이 더 낫다
  
    <br/>
- 싱글톤 레지스트리
    - 스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트로 사용되는 것은 지지함
    - 그렇지만 ‘`자바`’에서의 싱글톤 패턴 구현방식은 단점이 존재
        
        → 스프링이 직접 싱글톤 형태의 관리 기능을 제공 (싱글톤 레지스트리)
        
    - `싱글톤 레지스트리`의 장점: private 생성자 말고 평범한 클래스도 싱글톤으로 활용 가능
        
        → 싱글톤 방식인 어플리케이션 클래스여도 public 생성자를 가질 수 있음
        
    - 스프링 = IoC 컨테이너 = 어플리케이션 컨텍스트 = 빈팩토리 = 싱글톤 레지스트리
    - 스프링이 빈을 싱글톤으로 만드는 것도 결국 오브젝트 생성 방법을 제어하는 역할
    - 스프링 없이 DaoFactory만 이용한다면 위와 같은 문제점들을 가질 것임
<br/>

# 1.6.2 싱글톤과 오브젝트의 상태

- 싱글톤이 멀티스레드 환경이라면…
    - 여러 스레드가 동시에 접근 가능하므로 `주의` 해야한다
    - 상태정보를 내부에 갖고 있지 않은 `무상태` 방식으로 만들어져야 함
        
        다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 인스턴스 변수를 수정하는 것은 위험
        
        서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있음
        
    - 만약 상태 유지 방식으로 만든다면 → 개발자 혼자 테스트할 때는 문제발생 x
        
        여러 사용자가 동시에 접속할 때 문제 생김
        
        물론, `읽기 전용 값`이라면 상관없다
        
    - 요청 정보, DB, 서버 리소스 정보는 파라미터와 로컬 변수, 리턴 값을 이용하면 됨
    - 로컬 변수는 매번 독립 공간이 만들어지기 때문에 싱글톤이어도 값 덮어쓸 일은 발생x
<br/>

- 기존의 UserDao…
    - 인스턴스 변수를 멀티스레드 환경에서 활용하면 위의 문제들이 발생
    - 따라서 `로컬 변수`나 `파라미터`로 사용해야 한다
    - ConnectionMaker 인터페이스 타입 connectionMaker는 `읽기 전용 정보`이기 때문에 인스턴스 가능
    - DaoFactory에 @Bean을 붙였기 때문에 스프링이 관리하는 빈이 됨
    - 별다른 설정 없다면 오브젝트 한 개만 만들어져서 인스턴스 필드에 저장될 것
    - 이렇게 저장 용도라면 인스턴스 변수를 활용해도 좋다
    
    → 스프링이 한 번 초기화하면 이후에는 수정되지 않기 때문에 멀티스레드 환경에서도 문제 없다
    
<br/>

# 1.6.3 스프링 빈의 스코프

- 스프링 적용 범위
    - `빈의 스코프` : 빈이 생성되고, 존재하고, 적용되는 범위
    - 스프링 빈의 스코프는 기본적으로 싱글톤임
    - 싱글톤 스코프는 컨테이너에 한 개의 오브젝트만 만들어져서 제거되지 않는 한 계속 유지
<br/>

- 경우에 따라서…
    - `프로토타입 스코프` : 빈을 요청할 때마다 새로운 오브젝트를 만들어 줌
    - `요청 스코프` : 웹을 통해 HTTP 요청이 생길 때마다 생성됨
    - `세션 스코프` : 웹 세션과 스코프가 유사
